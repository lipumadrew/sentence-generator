//This project is intended as an improved version of the mixed messages project.
//The results may be more rudimentary, but I want them to be more dynamic, focusing on creating organic grammar structures from scratch, but randomly.

//Subject contains what sentance is about, predicate says something about the subject.
/* I'm thinking something like:

function generateSubject() ....

function generatePredicate() ....


Of course there will be a dictionary object. The object should be more complex than before, but lets not get to that yet...


In the subject, we will have the noun, which the sentance is about. This can be a person, place, or thing, including verbs like "running".
-The noun is the same regardless of the tense, but the plurality and tense will affect which verb should be used. 
for example: "She was running". "She ran." "She is running.", "She runs.", "She has run"

Notice for "She was running" and "She is running", "running" functions almost as a noun/adjective. I feel like this will be important later.

I could include pronoun support as well.

---------------------

The predicate is the "is running", or in the sentence "I saw an ugly witch", "saw an ugly witch" is the predicate.

Thinking abstractly, certain words have certain attributes, like good or bad tone, masculine or feminine, particularly for people.
Large vs small objects (You wouldn't hand someone a tree, but you would hand them a pumpkin), large places like a valley,
medium places like inside a building, and small places like a chair, a bed, or a car. This concept can be extrapolated to accomodate verbs.
Meaning, certain verbs only make sense with certain items. So maybe "eat" would only work for items which are "edible", and "sleep" would only
work for places, particularly small or medium.


---------------------

The dictionary object is going to be complex. I'm gonna run through two possible approaches I thought of.

So, if we need a random noun that is a small object that is edible, we could have something like:

    dictionary.nouns.smallobjects.isEdible[random index]
    -->I'm thinking for this approach, each property would be a variable that is generated by the function, and then it would be accessed
        something like dictionary[noun][nounType][nounSize] etc
        -->So we might need separate functions to help us access the words in the tree, like getNoun() or getAdj() since the traversal
            is different for each word type.

    This would mean that the dictionary would follow a hierarchical structure, in which the actual words themselves are the end nodes
    of a tree. They would be accessed by knowing their properties in advance.

    Another approach, could be having each word be an object, and each word would have it's own set of key value pairs.

    so, the word "ugly" would be a key, and the value would be another object, maybe looking like {wordType: adj, tone: negative, describesPerson: true, describesItem: true}

    Even with this approach, we could still incorporate these attributes into a tree structure,

    So we could have something like dictionary.adjectives.describesPerson.negative[0] <-- which would finally be an array of words with these criteria

    There is also potentially a hybrid approach, where we could have something like dictionary.adjectives[0] 
    and that item would have key value pairs associated with it.

    I think the way I would proceed is following a total tree structure, because accessing the items is the most consistent, and we know that the bottom of the tree
    would always be an array of items containing words that we could use for whatever criteria we need at that moment.

*/

//Here we go....
const dictionary = {
    noun: {
        person: {
            singular: {
                //Words that don't need "A" 
                proper: {
                    feminine: ["Hermione Granger", "The Wicked Witch", "Elvira", "Wednesday Addams", "Moaning Myrtle", "Lady Gaga", "Ellen Degeneres", "Yennefer", "Triss", "Ciri"],
                    masculine: ["Harry Potter", "Ron Weasley", "Hagrid", "Dracula", "Dumbledore", "The Devil", "Batman", "Spiderman", "Voldemort", "Frankenstein", "Geralt", "Tom Riddle"],
                    neutral: ["someone", "everyone", "nobody", "BMO", "C-3PO", "Demi Lovato", "The Dragonborn"],
                },
                //Words that need "A" or the
                nonProper: {
                    feminine: ["witch", "sorceress", "succubus", "woman", "lady", "girl", "enchantress"],
                    masculine: ["wizard", "man", "guy", "dude", "fellow", "druid", "gentleman", "headsman"],
                    neutral: ["spirit", "person", "magician", "executioner", "skeleton", "zombie", "vampire", "werewolf", "mummy", "ghost", "software-engineer", "college student", "necromancer", "groundskeeper"],
                }
            },
            //Words that don't need "A"
            //plural words behave the same even if they are proper, pronouns are always "they, we or you"
            plural: ["spirits", "ghouls", "ghosts", "witches", "sorceresses", "occultist", "succubi", "women", "ladies", "girls", "wizards", "men", "guys", "dudes", "people", "undead", "skeletons", "zombies", "vampires", "werewolves", "software-engineers", "college students", "necromancers", "groundskeepers"]
        },
        place: {
            //Words that don't need "A"  or the
            proper: {
                small: ["Hagrid's Hut", "The Room of Requirement"],
                medium: ["Safeway", "Dracula's castle", "Target", "Hogwarts", "Hogsmeade", ],
                large: ["San Francisco", "New York", "Tokyo", "London", "The Spirit Realm", "Outer Space", "The Underworld", "The Forbidden Forest", "The Upside Down"],
            },
            //Words that need "A"
            nonProper: {
                small: ["chair", "car", "train", "coffin", "closet", "backpack", "satchel", "locked chest", "cage", "jail cell"],
                medium: ["hut", "basement", "grocery store", "college", "secret passage", "classroom", "bathroom", "summoning circle", "graveyard"],
                large: ["city", "town", "village", "desert", "forest", "ruin", "temple", "tomb", "burial site", "graveyard"]
            },
        },
        //Rather than small, medium, large, I might get more specific...but we'll see
        thing: {
            //Words that don't need "A" or "The"
            proper: {
                singular: {
                    small: ["The Golden Snitch", "The Elder Wand", "Merlin's Beard", "The Sorcerer's Stone"],
                    medium: ["The Nimbus 2000"],
                    large: ["The Whomping Willow"],
                },
                plural: {
                    small: ["The Rings of Power", "Chaos Emeralds"],
                    medium: ["The Deathly Hallows", "The Elder Scrolls"],
                    large: ["The Standing Stones"]
                }
            },
            //Words that need "A" or "The"
            nonProper: {
                singular: {
                    //Moveable, hold in hand, throwable even
                    small: ["poison apple", "wand", "broom", "spellbook", "potion", "crystal ball", "taro card", "halloween candy", "severed head", "eye of newt", "carrot", "human heart", "voodoo doll", "dragon egg", "sword"],
                    //somewhat movable
                    medium: ["cauldron", "tombstone", "jack-o-lantern", "corpse", "skeleton", "pumpkin", "dead body", "bookcase"],
                    //immovable
                    large: ["tree", "monolith", "boulder", "pile of bones", "statue", "spires", "monument", "tar pit", "ritual site", "altar", "cataclysm","interdimensional rift"]
                },
                plural: {
                    small: ["magic mushrooms", "potions", "eggs", "crystal balls", "bones", "taro cards", "slugs", "spiders", "cobwebs", "scrolls", "halloween candies", "hippogriff feathers", "entrails"],
                    medium: ["pumpkins", "tombstones", "horcruxes", "brooms", "cauldrons", "jack-o-lanterns", "corpses", "severed limbs", "brains"],
                    large: ["trees", "monoliths", "boulders", "bone piles", "statues", "monuments", "buildings", "spires", "tar pits", "ritual sites", "altars", "cataclysms", "interdimensional rifts"]
                },
            }
        
        },
        // animal: {
        //     singular: ["cat", "dog", "spider", "unicorn", "frog", "owl", "bug"],
        //     plural: ["cats", "dogs", "spiders", "unicorns", "frogs", "owls", "bugs"]
        // },
    },
    adjective: {
        person: {
            posTone: ["delicious", "intelligent", "beautiful", "amazing", "hilarious", "great", "magical", "mythical", "generous", "kind", "attractive", "perfect", "flirty"],
            neuTone: ["tall", "short", "boring", "normal", "average", "regular"],
            negTone: ["stupid", "ugly", "smelly", "disgusting", "horrible", "outrageous", "awful", "weird", "mean", "selfish", "evil", "repulsive", "suspicious", "wicked"]
        },
        nonPerson: {
            posTone: ["delicious", "beautiful", "amazing", "hilarious", "great", "magical", "mythical", "perfect"],
            neuTone: ["green", "blue", "purple", "black", "red", "yellow", "glowing", "tall", "short", "boring", "normal", "average"],
            negTone: ["stupid", "ugly", "smelly", "disgusting", "horrible", "outrageous", "awful", "weird", "evil", "repulsive", "suspicious", "wicked"]
        }
    },


    //For now, I think I will only use simple past, present, and future tense. See: https://www.grammarly.com/blog/verb-tenses/#:~:text=The%20three%20main%20verb%20tenses,get%20twelve%20unique%20verb%20tenses.
    //I also need to think about verbs that happen to an object, versus ones that don't. ex: you don't breathe an apple, but you do eat an apple
    verb: {
        //He/she/it/that/proper
        singularThird: {
            //Needs object (i.e. Looked for - searched for - )
            needsObj: {
                small: {
                    pasTense: ["cursed", "had", "threw", "looked for", "consumed", "used", "took", "hid", "discovered", "found", "gave away", "transfigured"],
                    presTense: ["curses", "has", "throws", "looks for", "finds", "discovers", "hides", "steals", "consumes", "uses", "takes", "gives away", "transfigures"],
                    fuTense: ["will curse", "will have", "will throw", "will look for", "will find", "will discover", "will steal", "will consume", "will use", "will take", "will give away", "will transfigure"]
                },
                medium: {
                    pasTense: ["hid", "looked for", "used", "discovered", "found", "consumed", "stole", "gave away", "transfigured"],
                    presTense: ["looks for", "finds", "discovers", "hides", "steals", "uses", "takes", "gives away", "transfigures"],
                    fuTense: ["will throw", "will look for", "will find", "will discover", "will steal", "will use", "will take", "will transfigure"]
                },
                large: {
                    pasTense: ["looked for", "found", "discovered", "saw", "explored", "navigated", "avoided"],
                    presTense: ["looks for", "finds", "discovers", "sees", "explores", "navigates", "avoids"],
                    fuTense: ["will look for", "will find", "will discover", "will see", "will explore", "will navigate", "will avoid"]
                }
            },
            noObj: {
                pasTense: ["placed a curse", "died", "panicked", "was", "laughed", "slept", "ate", "cried", "casted a spell", "performed a ritual", "rested", "opened a portal", "saw the future", "exercised", "did arts and crafts", "brewed potions"],
                presTense: ["places a curse", "dies", "panicks", "is", "laughs", "sleeps", "eats", "cries", "casts spells", "performs rituals", "rests", "opens portals", "sees the future", "exercises", "does arts and crafts", "brews potions"],
                fuTense: ["will place a curse", "will die", "will panick", "will be", "will laugh", "will sleep", "will eat", "will cry", "will cast a spell", "will perform a ritual", "will rest", "will open a portal", "will see the future", "will exercise", "will do arts and crafts", "will brew potions"],
            }
        },
        //I/you/we/they
        plural: {
            needsObj: {
                small: {
                    pasTense: ["cursed", "had", "threw", "looked for", "consumed", "used", "took", "hid", "discovered", "found", "gave away", "transfigured"],
                    presTense: ["curse", "have", "throw", "look for", "find", "discover", "hide", "steal", "consume", "use", "take", "give away", "transfigure"],
                    fuTense: ["will curse", "will have", "will throw", "will look for", "will find", "will discover", "will steal", "will consume", "will use", "will take", "will give away", "will transfigure"]
                },
                medium: {
                    pasTense: ["cursed", "had", "hid", "looked for", "used", "discovered", "found", "consumed", "stole", "gave away", "transfigured"],
                    presTense: ["curse", "have", "look for", "find", "discover", "hide", "steal", "use", "take", "give away", "transfigure"],
                    fuTense: ["will curse", "will have", "will throw", "will look for", "will find", "will discover", "will steal", "will use", "will take", "will transfigure"]
                },
                large: {
                    pasTense: ["cursed", "looked for", "found", "discovered", "saw", "navigated", "avoided"],
                    presTense: ["curse", "look for", "find", "discover", "see", "navigate", "avoid"],
                    fuTense: ["will curse", "will look for", "will find", "will discover", "will see", "will navigate", "will avoid"]
                }
            },
            noObj: {
                pasTense: ["died", "panicked", "laughed", "slept", "ate", "cried", "casted a spell", "performed a ritual", "rested", "opened a portal", "saw the future", "exercised", "did arts and crafts", "brewed potions"],
                presTense: ["die", "panick", "laugh", "sleep", "eat", "cry", "cast a spell", "perform rituals", "rest", "open portals", "see the future", "exercise", "do arts and crafts", "brew potions"],
                fuTense: ["will die", "will panick", "will laugh", "will sleep", "will eat", "will cry", "will cast a spell", "will perform a ritual", "will rest", "will open a portal", "will see the future", "will exercise", "will do arts and crafts", "will brew potions"],
            }
        }
    },

    adverb: {
        nonTemporal: {
            negTone: ["stupidly", "clumsily", "terribly"],
            neuTone: ["carefully", "slowly", "gradually", "rapidly",],
            posTone: ["carelessly", "quickly", "intelligently", "skillfully", "wonderfully"]
        },
        temporal: {
            negTone: ["never", "rarely", "sometimes"],
            neuTone: ["suddenly"],
            posTone: ["usually", "frequently", "often", "always"],
        }
    },
};

//50 50 chance of true or false
const randBool = () => {
    let num = Math.floor(Math.random() * 2);
    if (num) {
        return true;
    }
    return false;
}

const randomTense = () => {
    let tense = "presTense";
    let num = Math.floor(Math.random() * 3);
    if (num == 0) {
        tense = "pasTense";
    } else if (num == 1) {
        tense = "presTense";
    } else {
        tense = "fuTense";
    }
    return tense;
}

const getRandFromArray = (array) => {
    let i = Math.floor(Math.random() * array.length);
    return array[i];
}

const randomIdentity = () => {
    let identity = "neutral";
    let num = Math.floor(Math.random() * 3);
    if (num == 0) {
        identity = "feminine";
    } else if (num == 1) {
        identity = "neutral";
    } else {
        identity = "masculine";
    }
    return identity;
}

const generatePronouns = (identity, isSubjectPlural) => {
    let pronouns;
    if (isSubjectPlural) {
        return ["they", "them", "their", "theirs"];
    } else {
        if (identity == "masculine") {
            pronouns = ["he", "him", "his", "his"];
        } else if (identity == "feminine") {
            pronouns = ["she", "her", "her", "hers"];
        } else {
            pronouns = ["they", "them", "their", "theirs"];
        }
        if (identity != "neutral") {
            //One in ten chance pronouns will be neutral
            let num = Math.floor(Math.random() * 11);
            if (num == 0) {
                pronouns = ["they", "them", "their", "theirs"]
            }
        }
    }
    return pronouns;
}

const hasAdverb = () => {
    let num = Math.floor(Math.random() * 8);
    if (num < 3) {
        return true;
    } else {
        return false;
    }
}

const getTemporal = () => {
    let yes = randBool();
    if (yes) {
        return "temporal";
    } else {
        return "nonTemporal";
    }
} 

const possiblyAddAdverb = (word, tone, temporal) => {
    if (hasAdverb()) {
        return word + " " + getRandFromArray(dictionary.adverb[temporal][tone]);
    } 
    return word;
}



const generateSize = () => {
    let num = Math.floor(Math.random() * 3);
    if (num == 0) {
        return "small";
    } else if (num == 1) {
        return "medium";
    } else {
        return "large";
    }
    
}

const getPlace = (isPlaceProper, objectSize) => {
    if (isPlaceProper) {
        return getRandFromArray(dictionary.noun.place.proper[objectSize]);
    } else {
        return getRandFromArray(dictionary.noun.place.nonProper[objectSize]);
    }
}

// one in four chance
const hasAdjective = () => {
    let num = Math.floor(Math.random() * 4)
    if (num == 0) {
        return true;
    }
    return false;
}

const getAdjective = (tone, isInanimate) => {
    if (isInanimate) {
        if (tone == "posTone") {
            return getRandFromArray(dictionary.adjective.nonPerson.posTone);
        } else if (tone == "neuTone") {
            return getRandFromArray(dictionary.adjective.nonPerson.neuTone);
        } else {
            return getRandFromArray(dictionary.adjective.nonPerson.negTone);
        }
    } else {
        if (tone == "posTone") {
            return getRandFromArray(dictionary.adjective.person.posTone);
        } else if (tone == "neuTone") {
            return getRandFromArray(dictionary.adjective.person.neuTone);
        } else {
            return getRandFromArray(dictionary.adjective.person.negTone);
        }
    }
}

const formatSentence = (sentence) => {
    return sentence.slice(0, 1).toUpperCase() + sentence.slice(1) + ".";
}

const getTone = () => {
    let num = Math.floor(Math.random() * 3);
    if (num == 0) {
        return "posTone";
    } else if (num == 1) {
        return "neuTone";
    } else {
        return "negTone";
    }
}

const possiblyAddAdjective = (word, tone, isInanimate) => {
    if (word != "everyone" && word != "nobody" && word != "someone") {
            if (hasAdjective()) {
            let adj = getAdjective(tone, isInanimate)
            if (word.slice(0, 3) == "The") {
                adj = adj.slice(0, 1).toUpperCase() + adj.slice(1);
                return word.slice(0, 3) + " " + adj + " " + word.slice(4);
            }
            return adj + " " + word;
        } else {
            return word;
        }
    }
    return word;
}

const possiblyRandomizeFutureTense = (word) => {
    if (randBool()) {
        let replacers = [" will not ", " won't ", " can't ", " didn't ", " wouldn't ", " would ", " could ", " should "];
    return word.replace(" will ", getRandFromArray(replacers));
    }
    return word;
    
}

const generateSentence = () => {
    //Needs to combine a subject and a predicate
    //Needs to keep track of the tense, plurality of subject and the predicate, and choose random words accordingly.
    
    let tense = randomTense();
    let isSubjectPlural = randBool();
    let isPredicatePlural = randBool();
    let isSubjectProper = randBool();
    let identity = randomIdentity();
    let pronoun = generatePronouns(identity, isSubjectPlural);
    let hasObject = randBool();
    let objectSize = generateSize();
    let isObjectProper = randBool();
    let isObjectPlural = randBool();

    let hasPlace = randBool();
    let isPlaceProper = randBool();

    let place = null;


    let subject = generateSubject(isSubjectPlural, identity, isSubjectProper);
    subject = possiblyAddAdjective(subject, getTone(), false);
    subject = possiblyAddAdverb(subject, getTone(), getTemporal());
    
    let predicate = generatePredicate(tense, isSubjectPlural, hasObject, objectSize, isObjectPlural, isObjectProper);
    let sentence = generateArticle(subject, isSubjectPlural, isSubjectProper) + subject + " " + predicate;

    if (hasPlace) {
        place = getPlace(isPlaceProper, objectSize);
        sentence += " in " + generateArticle(place, false, isPlaceProper) + possiblyAddAdjective(place, getTone(), true);
    }

    sentence = possiblyRandomizeFutureTense(sentence);

    return formatSentence(sentence);
}


//This can be modified to include qualifiers like "every", "some", etc.....
const generateArticle = (object, isObjectPlural, isObjectProper) => {
    let vowels = "aeiouAEIOU";
    if (isObjectProper) {
        return "";
    } else {
        if (isObjectPlural) {
            let articles = ["the ", "", "all of the ", "none of the ", "some of the ", "all ", "some ", "several ", "several of the ", "each of the ", "various ", "numerous ", "few ", "a few of the "]
            return getRandFromArray(articles);
        } else {
            let articles = ["the ", "every ", "each ", "every single ", "every other ", "the other ", "this ", "that "]
            if (vowels.includes(object[0])) {
                articles.push("an ");
            } else {
                articles.push("a ");
            }
            return getRandFromArray(articles);
        }
    }
}


//For now, subjects will always be people
const generateSubject = (isSubjectPlural, identity, isProper) => {
    //Needs to generate a subject i.e. the person
    if (isSubjectPlural) {
        return getRandFromArray(dictionary.noun.person.plural);
    } else {
        if (isProper) {
            return getRandFromArray(dictionary.noun.person.singular["proper"][identity]);
        } else {
            return getRandFromArray(dictionary.noun.person.singular["nonProper"][identity]);
        }
    }
}



const generatePredicate = (tense, isSubjectPlural, hasObject, objectSize, isObjectPlural, isObjectProper) => {
    //Needs to generate a predicate
    let objectPlurality
    let properProperty;
    let object;
    let verb;
    
    if (isObjectProper) {
        properProperty = "proper";
    } else {
        properProperty = "nonProper";
    }

    if (isObjectPlural) {
        objectPlurality = "plural";
    } else {
        objectPlurality = "singular";
    }

    if (isSubjectPlural) {
        if (hasObject) {
            // verb the/some/ objects
            verb = getRandFromArray(dictionary.verb.plural.needsObj[objectSize][tense])
            object = getRandFromArray(dictionary.noun.thing[properProperty][objectPlurality][objectSize])
            object = possiblyAddAdjective(object, getTone(), true);
            return verb + " " + generateArticle(object, isObjectPlural, isObjectProper) + object;
        } else {
            verb = getRandFromArray(dictionary.verb.plural.noObj[tense]);
            return verb;
        }

    } else {
        if (hasObject) {
            // verb a/the/an object
            verb = getRandFromArray(dictionary.verb.singularThird.needsObj[objectSize][tense]);
            object = getRandFromArray(dictionary.noun.thing[properProperty][objectPlurality][objectSize])
            object = possiblyAddAdjective(object, getTone(), true);
            return verb + " " + generateArticle(object, isObjectPlural, isObjectProper) + object
        } else {
            verb = getRandFromArray(dictionary.verb.singularThird.noObj[tense])
            return verb;
        }
    }
}


//Testing


for (let i = 0; i < 50; i++) {
    console.log(generateSentence());
}


