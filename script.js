//This project is intended as an improved version of the mixed messages project.
//The results may be more rudimentary, but I want them to be more dynamic, focusing on creating organic grammar structures from scratch, but randomly.

//Subject contains what sentance is about, predicate says something about the subject.
/* I'm thinking something like:

function generateSubject() ....

function generatePredicate() ....


Of course there will be a dictionary object. The object should be more complex than before, but lets not get to that yet...


In the subject, we will have the noun, which the sentance is about. This can be a person, place, or thing, including verbs like "running".
-The noun is the same regardless of the tense, but the plurality and tense will affect which verb should be used. 
for example: "She was running". "She ran." "She is running.", "She runs.", "She has run"

Notice for "She was running" and "She is running", "running" functions almost as a noun/adjective. I feel like this will be important later.

I could include pronoun support as well.

---------------------

The predicate is the "is running", or in the sentence "I saw an ugly witch", "saw an ugly witch" is the predicate.

Thinking abstractly, certain words have certain attributes, like good or bad tone, masculine or feminine, particularly for people.
Large vs small objects (You wouldn't hand someone a tree, but you would hand them a pumpkin), large places like a valley,
medium places like inside a building, and small places like a chair, a bed, or a car. This concept can be extrapolated to accomodate verbs.
Meaning, certain verbs only make sense with certain items. So maybe "eat" would only work for items which are "edible", and "sleep" would only
work for places, particularly small or medium.


---------------------

The dictionary object is going to be complex. I'm gonna run through two possible approaches I thought of.

So, if we need a random noun that is a small object that is edible, we could have something like:

    dictionary.nouns.smallobjects.isEdible[random index]
    -->I'm thinking for this approach, each property would be a variable that is generated by the function, and then it would be accessed
        something like dictionary[noun][nounType][nounSize] etc
        -->So we might need separate functions to help us access the words in the tree, like getNoun() or getAdj() since the traversal
            is different for each word type.

    This would mean that the dictionary would follow a hierarchical structure, in which the actual words themselves are the end nodes
    of a tree. They would be accessed by knowing their properties in advance.

    Another approach, could be having each word be an object, and each word would have it's own set of key value pairs.

    so, the word "ugly" would be a key, and the value would be another object, maybe looking like {wordType: adj, tone: negative, describesPerson: true, describesItem: true}

    Even with this approach, we could still incorporate these attributes into a tree structure,

    So we could have something like dictionary.adjectives.describesPerson.negative[0] <-- which would finally be an array of words with these criteria

    There is also potentially a hybrid approach, where we could have something like dictionary.adjectives[0] 
    and that item would have key value pairs associated with it.

    I think the way I would proceed is following a total tree structure, because accessing the items is the most consistent, and we know that the bottom of the tree
    would always be an array of items containing words that we could use for whatever criteria we need at that moment.

*/

//Here we go....
const dictionary = {
    noun: {
        person: {
            feminine: {

            },
            masculine: {
                
            },
            neutral: {

            }
        },
        place: {
            proper: {
                small: [],
                medium: ["Safeway"],
                large: ["San Francisco", "New York", "Tokyo"],
            },
            nonProper: {
                small: ["chair", "car", "train", "coffin"],
                medium: ["hut", "basement", "bathroom", "grocery store", "college"],
                large: ["spirit world", "underworld", "city", ""]
            },
        },
        //Rather than small, medium, large, I might get more specific...but we'll see
        thing: {
            small: {

            },
            medium: {

            },
            large: {
                
            }
        },
        animal: {

        },
    },
    adjective: {
        negTone: {
            
        },
        neuTone: {

        },
        posTone: {

        }
    },


    //For now, I think I will only use simple past, present, and future tense. See: https://www.grammarly.com/blog/verb-tenses/#:~:text=The%20three%20main%20verb%20tenses,get%20twelve%20unique%20verb%20tenses.
    verb: {
        pasTense: {

        },
        presTense: {

        },
        fuTense: {

        }
    },

    adverb: {
        nonTemporal: {
            negTone: {

            }
        },
        temporal: {
            posTone: {

            }
        }
    },
};